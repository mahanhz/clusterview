def publishedProjects = subprojects.findAll {
	(it.displayName.contains(":application:") && !it.displayName.contains(":application:periphery")) ||
			it.name == 'app-ui'
}

task jacocoMerge(type: JacocoMerge) {
	publishedProjects.each { subproject ->
		executionData subproject.tasks.withType(Test)
	}
	doFirst {
		executionData = files(executionData.findAll { it.exists() })
	}
}

task jacocoRootReport(type: JacocoReport, group: 'Coverage reports') {
	description = 'Generates an aggregate report from all subprojects'
	dependsOn publishedProjects.test, jacocoMerge

	additionalSourceDirs = files(publishedProjects.sourceSets.main.allSource.srcDirs)
	sourceDirectories = files(publishedProjects.sourceSets.main.allSource.srcDirs)
	classDirectories = files(publishedProjects.sourceSets.main.output)

	executionData jacocoMerge.destinationFile

	reports {
		html.enabled = true // human readable
		xml.enabled = true // required by coveralls
	}

	afterEvaluate {
		classDirectories = files(classDirectories.files.collect {
			fileTree(dir: it,
					exclude: ['org/amhzing/clusterview/configuration/**',
							  'org/amhzing/clusterview/appui/configuration/**'])
		})
	}
}

coveralls {
	sourceDirs = publishedProjects.sourceSets.main.allSource.srcDirs.flatten()
	jacocoReportPath = "${buildDir}/reports/jacoco/jacocoRootReport/jacocoRootReport.xml"
}

tasks.coveralls {
	group = 'Coverage reports'
	description = 'Uploads the aggregated coverage report to Coveralls'

	dependsOn jacocoRootReport
	onlyIf { true }
}